1. Как организован механизм генерации случайных чисел в библиотеке random?

В библиотеке написаны генераторы, с помощью которых можно получать псевдослучайные числа,
выдавая случайное число, у них меняется seed - состояние, от которого зависит следующее случайное число,
которое подается в следующий тип объекта в библиотеке -- распределение. После этого мы получаем случайное
число, подчиняющееся этому распределению.

2. Чем отличаются функциональные объекты от функций и лямбда-выражений?

Ф. О. - объект, пользовательский тип, хранит состояние в виде полей класса/структуры в С++.
        Может отличаться в зависимости от аргументов при создании.
А функции передается состояние через глобальные, статические переменные и через аргументы по ссылке.
Лямбда-выражения - безымянная функция, которую можно создавать в любом месте и сразу же вызывать.

3. Какими наборами возможностей обладают итераторы различных категорий?

Input Iterator, определены =, !=, ==, ++, *, -> для чтения
Output Iterator, определены =, !=, ==, ++, *, -> для записи
Forward Iterator, определены свойства II и OI, многопроходность
Bidirectional Iterator, определены свойства FI и --
Random_Access Iterator, определены свойства BI, <, >, <=, >=, +n, -n, i_2-i_1, [n]

4. Какая классификация предлагается для алгоритмов стандартной библиотеки?

Немодифицирующие: std::for_each, std::count_if, std::minmax_element, std::find_if
Модифицирующие: std::copy, std::copy_if, std::transform, std::iota, std::for_each (через &),
                std::fill, std::generate, std::generate_n, std::replace_if
Удаления: std::remove_if, std::unique, std::erase
Перестановки: std::reverse, std::shuffle (std::random_shuffle), std::rotate
Сортировки: std::nth_element, std::sort, std::stable_sort
Для упорядоченных диапазонов: std::binary_search, std::lower_bound, std::upper_bound, std::equal_range
Численные алгоритмы: std::accumulate

5. Почему алгоритмы стандартной библиотеки предпочтительнее собственных?

Потому что незачем создавать велосипед, существующие алгоритмы сохранят время, нервы на дебаг.
Они реализованы оптимально, компактно и быстро, а также они известны, что позволит другим разработчикам сразу понять
их назначение.



