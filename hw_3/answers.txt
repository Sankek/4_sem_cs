1. Когда используюся контейнеры типа (мульти) множества и отображение?

set, multiset, map, multimap - для хранения отсортированных данных, multi - с дубликатами. Map - хранение кроме ключа второго типа данных. 
Поиск, вставка, удаление за log(N)

unordered_set, unordered_map и мульти - быстрый поиск, вставка, удаление почти за O(1) (при малом заполнении хэш-таблицы), 
соответственно с дубликатами и без

2. Каким требованием должна удовлетворять качественная хэш-функция?
Она должна быстро вычислять хэш-код, не зависеть от заполненности таблицы и уже вычисленных хэш-функций.
Быть детерминированна, то есть на одинаковых данных давать один результат.
Давать равномерное заполнение хэш-таблиы с минимумом коллизий.

3. Из-за чего в хэш-таблицах возникают коллизии и как можно их разрешать?

Из-за того, что хэш - отображение из большего множества в меньшее, то есть некоторые элементы при отображении переходят в один образ.
Разрешать коллизии можно образованием списка элементов для данного значения хэша (метод цепочек).
Также можно после совпадения вычисленного хэша элемента с уже записанным в таблице, записывать его в следующую свободную ячейку (открытая адресация)

4. Почему сложность основных операций хэш-таблиц в худшем случае O(N)?

Потому что при большом количестве коллизий начинается обычный проход по всем элементам списка (метод цепочек) или элементам таблицы 
(открытая адресация) за O(N)

5. Что позволяет сделать инструмент создания контейнеров Boost.Multiindex?

Позволяет иметь для одних данных различные интерфейсы, например интерфейс set (сортировка), хэш-таблицы (операции за O(1)), vector (random access).
Но на реализацию различных интерфейсов расходуется дополнительная память.